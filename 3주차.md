# 3주차 

##클린코드는 왜 중요한가?

- 모두가 행복하기 위해서
- 도서 : 클린코드

## 프로그래밍이란?

- **기계가 실행할 정도로 요구사항을 명시하는 작업**이 프로그래밍이다.
- 요구사항은 기계가 실행할 정도로 **엄밀하고, 정확하고, 상세하고, 정형적**이어야한다.

코드를 자동화하려면 **요구사항을 애매하게 주어도 사람의 의도를 정확히 꿰뚤어 프로그램을 완벽하게 실행**할 수 있어야 한다.

**절대로 불가능한 기대다.**

코드는 항상 존재할 수 밖에 없다. 따라서 **우리는 코드를 깔끔하게 구현하는 것**에 관심을 가져야한다.

## 프로그래머가 나쁜 코드를 짜는 이유는?

- 제대로 구현할 시간이 없다고 생각해서
- 리팩토링하는데 시간을 보냈다가 팀장, 선배 개발자에게 욕 먹을까봐(기능 추가는 없다고 생각하기 때문에)
- 지겨워서 빨리 끝내려고
- 다른 업무가 너무 밀려서 후딱 해치우고 밀린 업무로 넘어가려고

우리 모두는 쓰레기 코드를 보며 나중에 손보겠다고 생각한다.

**"나중은 결코 오지 않는다."** -르블랑의 법칙

## 나쁜 코드로 치르는 대가?

- 나쁜 코드가 쌓일수록 팀 생산성은 떨어진다.

## 원대한 재설계의 꿈

- 생산성이 0에 수렴해 가는 시점에 프로그래머들은 재설계를 요구함
- 관리자들은 마음이 내키지 않지만 생산성이 바닥이라 어쩔 수 없이 허락함
- 레거시 프로젝트와 새로운 프로젝트가 병행하면서 경주를 시작
- 새로운 프로젝트는 기존 프로젝트의 기능을 따라 잡아야함
- 기존 프로젝트는 새로운 기능을 추가.
- 새로운 프로젝트는 기존 기능 + 새로 추가한 기능 따라 잡아야함.
- 끝나지 않는 반복

**기존에 싼 똥 덩어리에 새로운 똥덩어리가 하나가 더 추가 되면서** GG

기한을 맞추는 유일한 방법은,

그러니까 빨리 가는 유일한 방법은

**언제나 코드를 최대한 깨끗하게 유지하는 습관**이다.

### 리팩토링 원칙 1 - 메소드 인자 원칙

- 메소드(함수)에 인자가 너무 많다. 다음 원칙에 따라 메소드를 구현한다.
- 메소드(함수)에서 이상적인 인자 개수는 0개(무항)이다. 다음은 1개이고, 다음은 2개이다.
  3개는 가능한 피하는 편이 좋다. 4개 이상은 특별한 이유가 있어도 사용하면 안된다.

### 리팩토링 원칙2 - 규칙 8: 일급 Collection을 써라

- Collection을 포함한 클래스는 반드시 다른 멤버 변수가 없어야 한다.
- 각 Collection은 그 자체로 포장돼 있으므로 이제 Collection과 관련한 로직을 이 객체가 담당하도록 구현할 수 있다.

### 리팩토링 원칙3 - 상속(is-a 관계)과 조합(has-a 관계)

- 일급 collection을 구현할 때 접근 방법으로 상속과 조합 방법으로 구현할 수 있다.
- 객체의 중복(Lotto와 WinningLotto)을 제거할 때 상속과 조합 방법으로 구현할 수 있다.
- 이 두 가지 방법 중 어느 방법으로 구현하는 것이 더 좋을까?

## 유효성 체크

### 리팩토링 원칙 - 규칙 3: 모든 원시값과 문자열을 포장한다.

- primitive type과 String 기반으로 구현하는 부분이 있다면 객체로 포장하는 것을 고려해본다.

### 리팩토링 원칙 - 적절한 Collection(자료구조)을 활용하라.

- 대표적으로 List, Set, Map을 적절하게 활용한다.
- 적절한 자료구조가 없다면 나만의 자료구조를 구현한다.
  - 새로운 자료구조 == 나만의 커스텀 클래스

### 생성자 대신 정적 팩토리 메서드를 사용하라.

- **이름을 가짐으로써 객체 생성의 의도를 드러낼 수 있다.**
- **호출될 때마다 인스턴스를 새로 생성하지 않아도 된다. - singleton 패턴 적용할 경우**
- 반환 타입의 하위 타입 객체를 반환할 수 있다.
- 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

## 로또 기능 구현. 초기 설계 어떻게 할 것인가?

- 로또 생성
  - 수동 생성
  - 자동 생성
- 로또 비교
  - 1장의 로또를 비교
  - n장의 로또를 비교
  - 보너스 번호
- 당첨금
  - 수익률 계산

## TDD

TDD를 하려고 할 때 우선 기능을 분리해보자

- 모든 케이스를 다 테스트하는게 중요한게 아니라 필요한 케이스만 테스트 한다.
  - 1등을 테스트한다.
  - 2등을 테스트한다.(보너스 번호)
- 객체지향 테스트는 equals메소드를 통해 비교한다.
  - getter 메소드를 사용하지 않는다.
- 라이플 사이클이 같은 경우는 같이 묶어서 사용한다.
- 변수명을 잘 만들었으면 리팩토링할때 클래스명이 된다.
- 상속은 가능한 사용하지 않는것이 좋다. 조합을 통해서 하자.
- 중복값을 체크할 경우 자료구조 Set을 사용하는것도 생각해보자.
- 메소드를 분리하다보면 내가 사용하려던 기능이 추가되어 있는 경우가 많다.
- 유효성 체크는 밖에서 하지 말고 안에서 하자.
- 데이터 베이스 변경시 기존 데이터베이스와 새로운 데이터베이스에 같은 자료를 쌓다가 2번의 배포를 통해 기존 데이터베이스를 제거한다.
- Value Object란 값이 변경 불가능한 객체이다.
- 객체가 많이 만들어 지는 경우는 Map을 통해서 캐쉬 처리한다.
  - 객체 비교는 == 를 통해 가능하다
- 의존관계를 스프링처럼 주입시킨다. 
  - Interface를 통해서 주입한다.
- 데이터를 전달할때는 get을 통해서 구현해도 된다.
- 똑같은 프로그래밍을 10번 연습한다. 리팩토링 원칙을 1가지씩 적용한다.

### 절차

- 우선 클래스와 메소드를 만들자
- Input 과 Output을 정하자
- TDD는 항상 먼저 컴파일 에러가 발생하게 되어있다.
- 컴파일 에러가 나지 않게 리팩토링 해야한다.

- 기존 코드는 두고 코드를 복사해서 새로운 메소드를 생성한다.

- 새로운 메소드로  테스트 코드와 같이 테스트 한다.

- 테스트가 성공하면 기존 코드가 사용하는 곳이 없게 만들고 삭제한다.

- get메소드를 사용하지 말고 객체에 메시지를 보내게 구현하라.

- 방법이 없을때 메소드의 위치를 고민해보자(이 클래스 안에 있는게 맞는것일까?)

- 하다가 안되면 날리고 또 다시 도전한다.

- 생성자 인자가 2개 이상인 경우는 정적 팩토리 메소드를 써서 구현해서 의도를 드러낸다.

  ```java
  publid static Lotto from(List<Integer> Lotto){
      return new Lotto(lotto);
  }
  ```



